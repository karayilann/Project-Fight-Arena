<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Character/Player.Controller.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Character/Player.Controller.cs" />
              <option name="originalContent" value="using Unity.Netcode;&#10;using UnityEngine;&#10;&#10;namespace Character&#10;{&#10;    public partial class Player&#10;    {&#10;        [Header(&quot;Hareket Ayarları&quot;)] [SerializeField]&#10;        private float moveSpeed = 5f;&#10;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpForce = 10f;&#10;        [SerializeField] private float gravity = 20f;&#10;&#10;        [Header(&quot;Rotasyon Ayarları&quot;)] [SerializeField]&#10;        private float rotationSpeed = 10f;&#10;&#10;        [SerializeField] private float lookSensitivity;&#10;        [SerializeField] private float verticalLookLimit;&#10;        [SerializeField] private float horizontalLookLimit;&#10;&#10;        [Header(&quot;Zemin Kontrolü&quot;)] [SerializeField]&#10;        private float groundCheckDistance = 0.2f;&#10;&#10;        [SerializeField] private LayerMask groundMask;&#10;&#10;        [Header(&quot;Referanslar&quot;)] [SerializeField]&#10;        private PlayerInputHandler inputHandler;&#10;&#10;        [SerializeField] private CharacterController characterController;&#10;&#10;        private Vector2 _moveInput;&#10;        private Vector2 _lookInput;&#10;        private Vector3 _velocity;&#10;        private bool _isGrounded;&#10;        private bool _jumpRequested;&#10;&#10;        private float _cameraPitch = 0f;&#10;        private float _yawOffset = 0f;&#10;&#10;&#10;        private void ControllerUpdate()&#10;        {&#10;            if (!IsOwner) return;&#10;&#10;            CheckGroundStatus();&#10;            HandleCameraLook();&#10;            HandleMovement();&#10;        }&#10;&#10;        #region Zemin Kontrolü&#10;&#10;        private void CheckGroundStatus()&#10;        {&#10;            _isGrounded = characterController.isGrounded;&#10;&#10;            if (!_isGrounded)&#10;            {&#10;                Vector3 rayStart = transform.position + Vector3.up * 0.1f;&#10;                _isGrounded = Physics.Raycast(rayStart, Vector3.down, groundCheckDistance + 0.1f, groundMask);&#10;            }&#10;&#10;            if (_isGrounded &amp;&amp; _velocity.y &lt; 0)&#10;                _velocity.y = -2f;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Kamera Rotasyonu&#10;&#10;        private void HandleCameraLook()&#10;        {&#10;            float mouseX = _lookInput.x * lookSensitivity * Time.deltaTime;&#10;            float mouseY = _lookInput.y * lookSensitivity * Time.deltaTime;&#10;&#10;            _cameraPitch -= mouseY;&#10;            _cameraPitch = Mathf.Clamp(_cameraPitch, -verticalLookLimit, verticalLookLimit);&#10;&#10;            cinemachineCameraTarget.localRotation = Quaternion.Euler(_cameraPitch, 0f, 0f);&#10;&#10;            _yawOffset += mouseX;&#10;&#10;            if (Mathf.Abs(_yawOffset) &gt; horizontalLookLimit)&#10;            {&#10;                float rotateAmount = _yawOffset &gt; 0&#10;                    ? _yawOffset - horizontalLookLimit&#10;                    : _yawOffset + horizontalLookLimit;&#10;&#10;                transform.Rotate(Vector3.up, rotateAmount);&#10;&#10;                _yawOffset -= rotateAmount;&#10;            }&#10;&#10;            cinemachineCameraTarget.parent.localRotation = Quaternion.Euler(0, _yawOffset, 0);&#10;        }&#10;&#10;&#10;        // private void HandleCameraLook()&#10;        // {&#10;        //     float mouseX = _lookInput.x * lookSensitivity * Time.deltaTime;&#10;        //     float mouseY = _lookInput.y * lookSensitivity * Time.deltaTime;&#10;        //&#10;        //     _cameraPitch -= mouseY;&#10;        //     _cameraPitch = Mathf.Clamp(_cameraPitch, -verticalLookLimit, verticalLookLimit);&#10;        //&#10;        //     cinemachineCameraTarget.localRotation = Quaternion.Euler(_cameraPitch, 0f, 0f);&#10;        //&#10;        //     // Karakteri yatayda mouseX kadar döndür (Sınırsız şekilde)&#10;        //     transform.Rotate(Vector3.up, mouseX * rotationSpeed);&#10;        //&#10;        //     cinemachineCameraTarget.parent.localRotation = Quaternion.identity;&#10;        // }&#10;&#10;        #endregion&#10;&#10;        #region Hareket Sistemi&#10;&#10;        private void HandleMovement()&#10;        {&#10;            if (!_isGrounded)&#10;                _velocity.y -= gravity * Time.deltaTime;&#10;&#10;            if (_jumpRequested &amp;&amp; _isGrounded)&#10;            {&#10;                _velocity.y = jumpForce;&#10;                _jumpRequested = false;&#10;            }&#10;&#10;            Vector3 moveDir = Vector3.zero;&#10;&#10;            if (_moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                Vector3 forward = cinemachineCameraTarget.forward;&#10;                Vector3 right = cinemachineCameraTarget.right;&#10;                forward.y = 0f;&#10;                right.y = 0f;&#10;                forward.Normalize();&#10;                right.Normalize();&#10;&#10;                moveDir = (forward * _moveInput.y + right * _moveInput.x).normalized;&#10;            }&#10;&#10;            float speed = inputHandler.IsSprintPressed ? sprintSpeed : moveSpeed;&#10;            Vector3 finalMove = moveDir * speed + Vector3.up * _velocity.y;&#10;&#10;            characterController.Move(finalMove * Time.deltaTime);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Input Olayları&#10;&#10;        private void HandleMoveInput(Vector2 input)&#10;        {&#10;            _moveInput = input;&#10;        }&#10;&#10;        private void HandleMoveCanceled()&#10;        {&#10;            _moveInput = Vector2.zero;&#10;        }&#10;&#10;        private void HandleLookInput(Vector2 input)&#10;        {&#10;            _lookInput = input;&#10;        }&#10;&#10;        private void HandleJump()&#10;        {&#10;            if (_isGrounded)&#10;                _jumpRequested = true;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Debug&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            Vector3 rayStart = transform.position + Vector3.up * 0.1f;&#10;            Gizmos.color = _isGrounded ? Color.green : Color.red;&#10;            Gizmos.DrawLine(rayStart, rayStart + Vector3.down * (groundCheckDistance + 0.1f));&#10;            Gizmos.DrawWireSphere(rayStart + Vector3.down * (groundCheckDistance + 0.1f), 0.1f);&#10;        }&#10;&#10;        #endregion&#10;    }&#10;}" />
              <option name="updatedContent" value="using Unity.Netcode;&#10;using UnityEngine;&#10;&#10;namespace Character&#10;{&#10;    public partial class Player&#10;    {&#10;        [Header(&quot;Hareket Ayarları&quot;)] [SerializeField]&#10;        private float moveSpeed = 5f;&#10;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpForce = 10f;&#10;        [SerializeField] private float gravity = 20f;&#10;&#10;        [Header(&quot;Rotasyon Ayarları&quot;)] [SerializeField]&#10;        private float rotationSpeed = 10f;&#10;&#10;        [SerializeField] private float lookSensitivity;&#10;        [SerializeField] private float verticalLookLimit;&#10;        [SerializeField] private float horizontalLookLimit;&#10;&#10;        [Header(&quot;Zemin Kontrolü&quot;)] [SerializeField]&#10;        private float groundCheckDistance = 0.2f;&#10;&#10;        [SerializeField] private LayerMask groundMask;&#10;&#10;        [Header(&quot;Referanslar&quot;)] [SerializeField]&#10;        private PlayerInputHandler inputHandler;&#10;&#10;        [SerializeField] private CharacterController characterController;&#10;&#10;        private Vector2 _moveInput;&#10;        private Vector2 _lookInput;&#10;        private Vector3 _velocity;&#10;        private bool _isGrounded;&#10;        private bool _jumpRequested;&#10;&#10;        private float _cameraPitch = 0f;&#10;        private float _yawOffset = 0f;&#10;&#10;        private void ControllerUpdate()&#10;        {&#10;            if (!IsOwner) return;&#10;&#10;            CheckGroundStatus();&#10;            HandleCameraLook();&#10;            HandleMovement();&#10;        }&#10;&#10;        #region Zemin Kontrolü&#10;&#10;        private void CheckGroundStatus()&#10;        {&#10;            _isGrounded = characterController.isGrounded;&#10;&#10;            if (!_isGrounded)&#10;            {&#10;                Vector3 rayStart = transform.position + Vector3.up * 0.1f;&#10;                _isGrounded = Physics.Raycast(rayStart, Vector3.down, groundCheckDistance + 0.1f, groundMask);&#10;            }&#10;&#10;            if (_isGrounded &amp;&amp; _velocity.y &lt; 0)&#10;                _velocity.y = -2f;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Kamera Rotasyonu&#10;&#10;        private void HandleCameraLook()&#10;        {&#10;            float mouseX = _lookInput.x * lookSensitivity * Time.deltaTime;&#10;            float mouseY = _lookInput.y * lookSensitivity * Time.deltaTime;&#10;&#10;            _cameraPitch -= mouseY;&#10;            _cameraPitch = Mathf.Clamp(_cameraPitch, -verticalLookLimit, verticalLookLimit);&#10;&#10;            cinemachineCameraTarget.localRotation = Quaternion.Euler(_cameraPitch, 0f, 0f);&#10;&#10;            _yawOffset += mouseX;&#10;&#10;            if (Mathf.Abs(_yawOffset) &gt; horizontalLookLimit)&#10;            {&#10;                float rotateAmount = _yawOffset &gt; 0&#10;                    ? _yawOffset - horizontalLookLimit&#10;                    : _yawOffset + horizontalLookLimit;&#10;&#10;                transform.Rotate(Vector3.up, rotateAmount);&#10;&#10;                _yawOffset -= rotateAmount;&#10;            }&#10;&#10;            cinemachineCameraTarget.parent.localRotation = Quaternion.Euler(0, _yawOffset, 0);&#10;        }&#10;&#10;&#10;        // private void HandleCameraLook()&#10;        // {&#10;        //     float mouseX = _lookInput.x * lookSensitivity * Time.deltaTime;&#10;        //     float mouseY = _lookInput.y * lookSensitivity * Time.deltaTime;&#10;        //&#10;        //     _cameraPitch -= mouseY;&#10;        //     _cameraPitch = Mathf.Clamp(_cameraPitch, -verticalLookLimit, verticalLookLimit);&#10;        //&#10;        //     cinemachineCameraTarget.localRotation = Quaternion.Euler(_cameraPitch, 0f, 0f);&#10;        //&#10;        //     // Karakteri yatayda mouseX kadar döndür (Sınırsız şekilde)&#10;        //     transform.Rotate(Vector3.up, mouseX * rotationSpeed);&#10;        //&#10;        //     cinemachineCameraTarget.parent.localRotation = Quaternion.identity;&#10;        // }&#10;&#10;        #endregion&#10;&#10;        #region Hareket Sistemi&#10;&#10;        private void HandleMovement()&#10;        {&#10;            if (!_isGrounded)&#10;                _velocity.y -= gravity * Time.deltaTime;&#10;&#10;            if (_jumpRequested &amp;&amp; _isGrounded)&#10;            {&#10;                _velocity.y = jumpForce;&#10;                _jumpRequested = false;&#10;            }&#10;&#10;            Vector3 moveDir = Vector3.zero;&#10;&#10;            if (_moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                Vector3 forward = cinemachineCameraTarget.forward;&#10;                Vector3 right = cinemachineCameraTarget.right;&#10;                forward.y = 0f;&#10;                right.y = 0f;&#10;                forward.Normalize();&#10;                right.Normalize();&#10;&#10;                moveDir = (forward * _moveInput.y + right * _moveInput.x).normalized;&#10;            }&#10;&#10;            float speed = inputHandler.IsSprintPressed ? sprintSpeed : moveSpeed;&#10;            Vector3 finalMove = moveDir * speed + Vector3.up * _velocity.y;&#10;&#10;            characterController.Move(finalMove * Time.deltaTime);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Input Olayları&#10;&#10;        private void HandleMoveInput(Vector2 input)&#10;        {&#10;            _moveInput = input;&#10;        }&#10;&#10;        private void HandleMoveCanceled()&#10;        {&#10;            _moveInput = Vector2.zero;&#10;        }&#10;&#10;        private void HandleLookInput(Vector2 input)&#10;        {&#10;            _lookInput = input;&#10;        }&#10;&#10;        private void HandleJump()&#10;        {&#10;            if (_isGrounded)&#10;                _jumpRequested = true;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Debug&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            Vector3 rayStart = transform.position + Vector3.up * 0.1f;&#10;            Gizmos.color = _isGrounded ? Color.green : Color.red;&#10;            Gizmos.DrawLine(rayStart, rayStart + Vector3.down * (groundCheckDistance + 0.1f));&#10;            Gizmos.DrawWireSphere(rayStart + Vector3.down * (groundCheckDistance + 0.1f), 0.1f);&#10;        }&#10;&#10;        #endregion&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>