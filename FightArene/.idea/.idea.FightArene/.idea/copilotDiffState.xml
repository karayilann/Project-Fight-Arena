<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/PlayerController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/PlayerController.cs" />
              <option name="originalContent" value="using Unity.Netcode.Components;&#10;using UnityEngine;&#10;&#10;namespace Player&#10;{&#10;    [RequireComponent(typeof(CharacterController))]&#10;    [RequireComponent(typeof(PlayerInputHandler))]&#10;    public class PlayerController : NetworkTransform&#10;    {&#10;        [Header(&quot;Hareket Ayarları&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpForce = 5f;&#10;        [SerializeField] private float gravity = -9.81f;&#10;        [SerializeField] private float rotationSpeed = 10f;&#10;        &#10;        [Header(&quot;Zemin Kontrolü&quot;)]&#10;        [SerializeField] private Transform groundCheck;&#10;        [SerializeField] private float groundDistance = 0.4f;&#10;        [SerializeField] private LayerMask groundMask;&#10;        &#10;        private CharacterController _characterController;&#10;        private PlayerInputHandler _inputHandler;&#10;        private Vector3 _velocity;&#10;        private bool _isGrounded;&#10;        private Vector2 _currentMoveInput;&#10;        &#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _characterController = GetComponent&lt;CharacterController&gt;();&#10;            _inputHandler = GetComponent&lt;PlayerInputHandler&gt;();&#10;        }&#10;        &#10;        private void OnEnable()&#10;        {&#10;            // Input eventlerine abone ol&#10;            _inputHandler.OnMovePerformed += HandleMoveInput;&#10;            _inputHandler.OnMoveCanceled += HandleMoveCanceled;&#10;            _inputHandler.OnJumpPerformed += HandleJump;&#10;        }&#10;        &#10;        private void OnDisable()&#10;        {&#10;            // Input eventlerinden ayrıl&#10;            _inputHandler.OnMovePerformed -= HandleMoveInput;&#10;            _inputHandler.OnMoveCanceled -= HandleMoveCanceled;&#10;            _inputHandler.OnJumpPerformed -= HandleJump;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            if (!IsOwner) return; // Sadece owner oyuncu kontrol edebilir&#10;            &#10;            CheckGroundStatus();&#10;            ApplyGravity();&#10;            MoveCharacter();&#10;        }&#10;        &#10;        private void CheckGroundStatus()&#10;        {&#10;            // Zemin kontrolü - groundCheck varsa kullan, yoksa karakterin altını kontrol et&#10;            if (groundCheck != null)&#10;            {&#10;                _isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);&#10;            }&#10;            else&#10;            {&#10;                _isGrounded = _characterController.isGrounded;&#10;            }&#10;            &#10;            // Yerde ise velocity'yi sıfırla&#10;            if (_isGrounded &amp;&amp; _velocity.y &lt; 0)&#10;            {&#10;                _velocity.y = -2f;&#10;            }&#10;        }&#10;        &#10;        private void ApplyGravity()&#10;        {&#10;            _velocity.y += gravity * Time.deltaTime;&#10;        }&#10;        &#10;        private void MoveCharacter()&#10;        {&#10;            // Hareket yönünü hesapla&#10;            Vector3 moveDirection = new Vector3(_currentMoveInput.x, 0f, _currentMoveInput.y);&#10;            &#10;            if (moveDirection.magnitude &gt;= 0.1f)&#10;            {&#10;                // Kamera yönüne göre hareket yönünü ayarla&#10;                moveDirection = Camera.main != null &#10;                    ? Camera.main.transform.TransformDirection(moveDirection) &#10;                    : moveDirection;&#10;                moveDirection.y = 0f; // Y eksenini sıfırla&#10;                moveDirection.Normalize();&#10;                &#10;                // Sprint kontrolü&#10;                float currentSpeed = _inputHandler.IsSprintPressed ? sprintSpeed : moveSpeed;&#10;                &#10;                // Hareketi uygula&#10;                Vector3 move = moveDirection * currentSpeed;&#10;                _characterController.Move(move * Time.deltaTime);&#10;                &#10;                // Karakteri hareket yönüne döndür&#10;                if (moveDirection != Vector3.zero)&#10;                {&#10;                    Quaternion targetRotation = Quaternion.LookRotation(moveDirection);&#10;                    transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);&#10;                }&#10;            }&#10;            &#10;            // Gravity ve velocity'yi uygula&#10;            _characterController.Move(_velocity * Time.deltaTime);&#10;        }&#10;        &#10;        #region Input Handler Metodları&#10;        &#10;        private void HandleMoveInput(Vector2 moveInput)&#10;        {&#10;            _currentMoveInput = moveInput;&#10;        }&#10;        &#10;        private void HandleMoveCanceled()&#10;        {&#10;            _currentMoveInput = Vector2.zero;&#10;        }&#10;        &#10;        private void HandleJump()&#10;        {&#10;            if (_isGrounded)&#10;            {&#10;                _velocity.y = Mathf.Sqrt(jumpForce * -2f * gravity);&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Debug Gizmos&#10;        &#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            if (groundCheck != null)&#10;            {&#10;                Gizmos.color = _isGrounded ? Color.green : Color.red;&#10;                Gizmos.DrawWireSphere(groundCheck.position, groundDistance);&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;    }&#10;}" />
              <option name="updatedContent" value="using Unity.Netcode.Components;&#10;using UnityEngine;&#10;&#10;namespace Player&#10;{&#10;    [RequireComponent(typeof(CharacterController))]&#10;    [RequireComponent(typeof(PlayerInputHandler))]&#10;    public class PlayerController : NetworkTransform&#10;    {&#10;        [Header(&quot;Hareket Ayarları&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpForce = 5f;&#10;        [SerializeField] private float gravity = -9.81f;&#10;        [SerializeField] private float rotationSpeed = 10f;&#10;        &#10;        [Header(&quot;Zemin Kontrolü&quot;)]&#10;        [SerializeField] private Transform groundCheck;&#10;        [SerializeField] private float groundDistance = 0.4f;&#10;        [SerializeField] private LayerMask groundMask;&#10;        &#10;        private CharacterController _characterController;&#10;        private PlayerInputHandler _inputHandler;&#10;        private Vector3 _velocity;&#10;        private bool _isGrounded;&#10;        private Vector2 _currentMoveInput;&#10;        &#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _characterController = GetComponent&lt;CharacterController&gt;();&#10;            _inputHandler = GetComponent&lt;PlayerInputHandler&gt;();&#10;        }&#10;        &#10;        private void OnEnable()&#10;        {&#10;            // Input eventlerine abone ol&#10;            _inputHandler.OnMovePerformed += HandleMoveInput;&#10;            _inputHandler.OnMoveCanceled += HandleMoveCanceled;&#10;            _inputHandler.OnJumpPerformed += HandleJump;&#10;        }&#10;        &#10;        private void OnDisable()&#10;        {&#10;            // Input eventlerinden ayrıl&#10;            _inputHandler.OnMovePerformed -= HandleMoveInput;&#10;            _inputHandler.OnMoveCanceled -= HandleMoveCanceled;&#10;            _inputHandler.OnJumpPerformed -= HandleJump;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            if (!IsOwner) return; // Sadece owner oyuncu kontrol edebilir&#10;            &#10;            CheckGroundStatus();&#10;            ApplyGravity();&#10;            MoveCharacter();&#10;        }&#10;        &#10;        private void CheckGroundStatus()&#10;        {&#10;            // Zemin kontrolü - groundCheck varsa kullan, yoksa karakterin altını kontrol et&#10;            if (groundCheck != null)&#10;            {&#10;                _isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);&#10;            }&#10;            else&#10;            {&#10;                _isGrounded = _characterController.isGrounded;&#10;            }&#10;            &#10;            // Yerde ise velocity'yi sıfırla&#10;            if (_isGrounded &amp;&amp; _velocity.y &lt; 0)&#10;            {&#10;                _velocity.y = -2f;&#10;            }&#10;        }&#10;        &#10;        private void ApplyGravity()&#10;        {&#10;            _velocity.y += gravity * Time.deltaTime;&#10;        }&#10;        &#10;        private void MoveCharacter()&#10;        {&#10;            // Hareket yönünü hesapla&#10;            Vector3 moveDirection = new Vector3(_currentMoveInput.x, 0f, _currentMoveInput.y);&#10;            &#10;            if (moveDirection.magnitude &gt;= 0.1f)&#10;            {&#10;                // Kamera yönüne göre hareket yönünü ayarla&#10;                moveDirection = Camera.main != null &#10;                    ? Camera.main.transform.TransformDirection(moveDirection) &#10;                    : moveDirection;&#10;                moveDirection.y = 0f; // Y eksenini sıfırla&#10;                moveDirection.Normalize();&#10;                &#10;                // Sprint kontrolü&#10;                float currentSpeed = _inputHandler.IsSprintPressed ? sprintSpeed : moveSpeed;&#10;                &#10;                // Hareketi uygula&#10;                Vector3 move = moveDirection * currentSpeed;&#10;                _characterController.Move(move * Time.deltaTime);&#10;                &#10;                // Karakteri hareket yönüne döndür&#10;                if (moveDirection != Vector3.zero)&#10;                {&#10;                    Quaternion targetRotation = Quaternion.LookRotation(moveDirection);&#10;                    transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);&#10;                }&#10;            }&#10;            &#10;            // Gravity ve velocity'yi uygula&#10;            _characterController.Move(_velocity * Time.deltaTime);&#10;        }&#10;        &#10;        #region Input Handler Metodları&#10;        &#10;        private void HandleMoveInput(Vector2 moveInput)&#10;        {&#10;            _currentMoveInput = moveInput;&#10;        }&#10;        &#10;        private void HandleMoveCanceled()&#10;        {&#10;            _currentMoveInput = Vector2.zero;&#10;        }&#10;        &#10;        private void HandleJump()&#10;        {&#10;            if (_isGrounded)&#10;            {&#10;                _velocity.y = Mathf.Sqrt(jumpForce * -2f * gravity);&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Debug Gizmos&#10;        &#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            if (groundCheck != null)&#10;            {&#10;                Gizmos.color = _isGrounded ? Color.green : Color.red;&#10;                Gizmos.DrawWireSphere(groundCheck.position, groundDistance);&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>